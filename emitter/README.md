########  Первый ########
Первый эмиттер сделал влоб.

Сложность:
    добавление - O(1)
    удаление - O(n1), где n1 - количество зарегистрированных обработчиков на текущий момент
    вызов - O(n2), где n2 - количество зарегистрированных обработчиков на текущий момент

Доп.память:
    На подписку храним объект с текущими обработчиками.
    Храним объект с функцями-обработчиками, которые могут повторяться.


########  Второй ########

Во втором, возможно, перемудрил, но

идея была в том, чтобы хранить функции-обработчки в отдельном объекте (handlers),
что приводит к экономии памяти из-за избавления от повторного добавления функций-обработчиков.

В этом объекте ключ - это название функции-обработчика (handlerId), а значение - объект с полям links и func,
т.е. с количеством ссылок на данную функцию-обработчик и, собственно, сама функция-обработчик.

Привязка событий к этим функциями-обработчикам хранится в объекте eventNames,
в котором ключи это названия событий (event), а значение это объект, где свойства это
названия функций (handlerId), а значения - ссылки на соответствующие функции-обработчики из
handlers (конечно, можно было бы хранить просто массив handlerId, но тогда удаление
функции-обработчика пришлось бы выполнять из массива, что скорее всего дольше, чем из объекта,
но в этом я не уверен).

Минус вижу в том, что это плохо будет работать с анонимными функциями-обработчиками, но
с другой стороны с ними в любом случае будет не очень, т.к. не будут работать отписки.

Сложность:
    добавление - O(1)
    удаление - O(1)
    вызов - O(n), где n - количество зарегистрированных обработчиков на текущий момент

Доп.память:
    Храним объект с функциями-обработчиками, которые не повторяются.
    Храним объект с названиями ивентов и ссылками на соответствующие обработчики.
    При подписки и отписки храним объект текущего ивента и обработчика.
